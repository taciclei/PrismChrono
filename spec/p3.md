
# Projet : POC Ordinateur Ternaire Base 24
# Architecture : üè≥Ô∏è‚Äçüåà Logic GPR Base-24 Ternary + (LGBT+)

*   **L** : Logic (Logique ternaire √©quilibr√©e)
*   **G** : GPR (Utilisation de Registres G√©n√©raux)
*   **B** : Base-24 (Syst√®me de num√©ration principal pour les Trytes)
*   **T** : Ternary (Technologie de trit sous-jacente)
*   **+** : Extras (√âtats sp√©ciaux, architecture √©tendue 24t/16MTr, au-del√† du binaire)

---

# Phase 3 : Architecture Syst√®me (pour LGBT+ √âtendue 24t/16MTr)

**Version :** 2.0 (Adapt√©e √† l'architecture 24 trits / 16 MTrytes)
**Date :** 2024-08-28
**D√©pendances :**
*   Phase 1 - D√©finition Fondamentale (v1.2 - Base Tryte/B24/Ternaire)
*   Phase 2 - Unit√© Arithm√©tique et Logique (ALU) (v2.0 - ALU 24 trits)

## 1. Introduction

Cette phase d√©finit l'organisation globale de l'architecture **LGBT+** √©tendue. Elle s'appuie sur les d√©finitions fondamentales (trit, tryte, Base 24, √©tats sp√©ciaux) et l'ALU 24 trits pour d√©crire l'interaction entre les registres, la m√©moire (maintenant 16 MTrytes), et le c≈ìur de contr√¥le via un **jeu d'instructions (ISA) r√©vis√© et d√©taill√©**.

L'objectif est de d√©finir une architecture **RISC-like (Load/Store)**, coh√©rente et suffisamment compl√®te pour servir de base solide √† la simulation (Phase 4) et permettre l'ex√©cution d'algorithmes significatifs. L'ISA s'inspire de la simplicit√© de RV32I (RISC-V Base Integer ISA) mais est adapt√©e √† notre mod√®le ternaire 24 trits.

## 2. Unit√©s de Donn√©es et Organisation M√©moire

### 2.1 Unit√©s Fondamentales
*   **Trit :** Unit√© atomique `{N, Z, P}`.
*   **Tryte :** Groupe de **3 trits**. Repr√©sente un chiffre Base 24 (0-23) ou un √©tat sp√©cial (`UNDEF`, `NULL`, `NaN`). C'est l'**unit√© adressable** en m√©moire.
*   **Word (Mot) :** Unit√© principale de traitement (registres, ALU). **24 trits (8 trytes)**.

### 2.2 Mod√®le M√©moire
*   **Espace d'Adressage :** Lin√©aire, plat, **16 M√©gaTrytes (16 777 216 trytes)**.
*   **Adressage :** Par **tryte**. Adresses de **16 trits**.
*   **Endianness :** **Little-Endian**. Pour un mot de 8 trytes `W = (T7..T0)` stock√© √† l'adresse `A`:
    *   `Mem[A] = T0` (Tryte de poids le plus faible)
    *   `Mem[A+1] = T1`
    *   ...
    *   `Mem[A+7] = T7` (Tryte de poids le plus fort)
*   **Alignement :**
    *   Les acc√®s Tryte (`LOADT`, `STORET`) peuvent se faire √† n'importe quelle adresse.
    *   Les acc√®s Mot (`LOADW`, `STOREW`) **doivent √™tre align√©s** sur une adresse multiple de 8 (la taille d'un mot en trytes). Une tentative d'acc√®s non align√© g√©n√®re une exception (Misaligned Access).

```mermaid
graph LR
    subgraph M√©moire (16 MTrytes)
        direction LR
        A0[Tryte @ Addr A]
        A1[Tryte @ Addr A+1]
        A2[...]
        A7[Tryte @ Addr A+7]
        A8[Tryte @ Addr A+8]
    end
    subgraph Mot W (24 trits / 8 trytes)
        T0(T0: LST) --> T1 --> T2 --> T3 --> T4 --> T5 --> T6 --> T7(T7: MST)
    end
    T0 --> A0
    T1 --> A1
    T7 --> A7
```

## 3. Registres du Processeur

Tous les registres principaux (sauf FR) ont une taille de **1 Word (24 trits)**.

### 3.1 Registres G√©n√©raux (GPR)
*   **Nombre :** 8 registres, `R0` √† `R7`.
*   **Taille :** 24 trits chacun.
*   **R√¥le :** Op√©randes et r√©sultats pour ALU, stockage d'adresses.
*   **Convention `R0` :** Trait√© comme un registre normal (peut √™tre lu et √©crit). Contrairement √† RISC-V o√π x0 est c√¢bl√© √† z√©ro. *Alternative : Le c√¢bler √† z√©ro simplifierait certaines op√©rations, comme MOV Rd, Rs -> ADD Rd, Rs, R0.* **D√©cision POC : R0 est normal.**

### 3.2 Registres Sp√©ciaux
*   **`PC` (Program Counter) :**
    *   Taille : **24 trits** (contient l'adresse 16 trits de la prochaine instruction, align√©e).
    *   R√¥le : Adresse m√©moire (en trytes) de la **prochaine instruction** √† ex√©cuter. Doit toujours contenir une adresse align√©e sur la taille de l'instruction.
*   **`SP` (Stack Pointer) :**
    *   Taille : **24 trits** (contient l'adresse 16 trits du sommet de pile).
    *   R√¥le : Pointeur vers le sommet de la pile en m√©moire. La pile cro√Æt vers les adresses **basses** (convention choisie). Doit id√©alement rester align√© sur la taille du mot (8 trytes) pour PUSH/POP efficaces.
*   **`FR` (Flag Register) :**
    *   Taille : **3 trits** (1 Tryte).
    *   R√¥le : Stocke les flags principaux mis √† jour par l'ALU.
    *   Structure (Rappel Phase 2) :
        *   `t0` (poids faible) : `ZF` (Binary: Z=0, P=1 si Z√©ro)
        *   `t1` : `SF` (Binary: Z=0 si <0, P=1 si >=0)
        *   `t2` (poids fort) : `XF` (Binary: Z=0 si Valide, P=1 si Sp√©cial)
    *   *Note :* Les flags `CF` et `OF` ne sont pas stock√©s dans ce FR minimaliste. Des instructions de branchement sp√©cifiques pourraient les tester implicitement ou un FR √©tendu serait n√©cessaire.

## 4. Jeu d'Instructions (ISA) : LGBT+ ISA v1.0

### 4.1 Philosophie
*   **RISC-like, Load/Store.**
*   **Adapt√©e au Ternaire / Base 24 / 24 trits.**
*   **Inspir√©e par RV32I** pour la couverture fonctionnelle de base.

### 4.2 Longueur d'Instruction
*   **Fixe : 12 trits (4 trytes)**.
    *   Compromis entre densit√© de code et capacit√© √† encoder les informations n√©cessaires (OpCode, registres, imm√©diats/offsets).
    *   Simplifie le d√©codage et l'incr√©mentation du PC.
    *   Le PC est incr√©ment√© de **4** (trytes) apr√®s chaque fetch (sauf sauts).

### 4.3 Encodage des Registres
*   Avec 8 GPR (R0-R7), nous avons besoin de `ceil(log3(8)) = 2` trits pour sp√©cifier un registre.
    *   `R0 = (N,N)`, `R1 = (N,Z)`, `R2 = (N,P)`, `R3 = (Z,N)`, `R4 = (Z,Z)`, `R5 = (Z,P)`, `R6 = (P,N)`, `R7 = (P,P)`.

### 4.4 Formats d'Instruction (12 trits)

*   **Format R (Register)** : Op√©rations ALU Registre-Registre.
    ```
    | OpCode (3t) | Rd (2t) | Rs1 (2t) | Rs2 (2t) | Func (3t) |
    ```
    *   `OpCode`: Identifie le format et le type g√©n√©ral (ex: ALU Reg-Reg).
    *   `Rd`: Registre destination (2 trits).
    *   `Rs1`: Registre source 1 (2 trits).
    *   `Rs2`: Registre source 2 (2 trits).
    *   `Func`: Distingue l'op√©ration sp√©cifique (ex: ADD vs SUB vs MIN...). Permet 27 op√©rations R.

*   **Format I (Immediate)** : ALU avec petit imm√©diat, ou Load.
    ```
    | OpCode (3t) | Rd (2t) | Rs1 (2t) | Immediate (5t)     |
    ```
    *   `OpCode`: Identifie le format (ALU-Imm ou LOAD).
    *   `Rd`: Registre destination.
    *   `Rs1`: Registre source 1 (pour ALU) ou Base Adresse (pour LOAD).
    *   `Immediate`: Valeur imm√©diate sign√©e de 5 trits (Plage : `-(3^5-1)/2` √† `+(3^5-1)/2` = -121 √† +121). Utilis√©e comme op√©rande ou offset d'adresse.

*   **Format S (Store)** : Store en m√©moire.
    ```
    | OpCode (3t) | Src (2t) | Base(2t) | Offset (5t)      |
    ```
    *   `OpCode`: Identifie le format (STORE).
    *   `Src`: Registre source contenant la donn√©e √† stocker (ancien `Rd` du format I).
    *   `Base`: Registre contenant l'adresse de base (ancien `Rs1`).
    *   `Offset`: D√©calage sign√© de 5 trits (-121 √† +121) ajout√© √† Base.

*   **Format B (Branch)** : Branchements conditionnels.
    ```
    | OpCode (3t) | Cond(3t) | Rs1 (2t) | Offset (4t)      |
    ```
    *   `OpCode`: Identifie le format (BRANCH).
    *   `Cond`: Sp√©cifie la condition de branchement (3 trits = 27 conditions possibles). Ex: `EQ`, `NE`, `LT`, `GE`, `LTU`, `GEU` (Unsigned √† d√©finir), `XS`, `XN`.
    *   `Rs1`: Registre source 1 (utilis√© pour comparaison implicite avec Z√©ro ou avec Rs2? *D√©cidons :* pour ce POC, conditions bas√©es uniquement sur FR. Rs1 est ignor√©/mis √† Z,Z).
    *   `Offset`: D√©calage sign√© de 4 trits (Plage : -40 √† +40). Multipli√© par 4 (taille instruction en trytes) et ajout√© au PC si la condition est vraie. `PC <- PC + SignExtend(Offset) * 4`.

*   **Format U (Upper Immediate)** : Chargement des trits sup√©rieurs d'une constante.
    ```
    | OpCode (3t) | Rd (2t) | Immediate (7t)        |
    ```
    *   `OpCode`: Identifie le format (LUI).
    *   `Rd`: Registre destination.
    *   `Immediate`: Valeur imm√©diate de 7 trits. Plac√©e dans les trits sup√©rieurs de Rd (t17 √† t23 ? ou t7 √† t13 si on construit en 2 √©tapes ?). Les trits inf√©rieurs sont mis √† Z√©ro. *Utile pour construire des constantes ou adresses 16 trits.*

*   **Format J (Jump)** : Sauts inconditionnels.
    ```
    | OpCode (3t) | Rd (2t) | Offset (7t)           |
    ```
    *   `OpCode`: Identifie le format (JAL / JALR).
    *   `Rd`: Registre destination pour stocker l'adresse de retour (`PC + 4`). Si `Rd = R0`, le retour n'est pas stock√© (simple JMP).
    *   `Offset`: D√©calage sign√© de 7 trits (Plage : -1093 √† +1093). Multipli√© par 4 et ajout√© au PC (`JAL`).

### 4.5 Liste d'Instructions Inspir√©e de RV32I (Adapt√©e √† LGBT+)

*(Les OpCodes/Func num√©riques exacts sont √† attribuer)*

**Op√©rations sur Registres (Format R)**
*   `ADD Rd, Rs1, Rs2`: `Rd <- Rs1 + Rs2` (Addition 24t). `Func = ADD_F`.
*   `SUB Rd, Rs1, Rs2`: `Rd <- Rs1 - Rs2` (Soustraction 24t). `Func = SUB_F`.
*   `MIN Rd, Rs1, Rs2`: `Rd <- TRIT_MIN(Rs1, Rs2)` (Logique trit-√†-trit 24t). `Func = MIN_F`.
*   `MAX Rd, Rs1, Rs2`: `Rd <- TRIT_MAX(Rs1, Rs2)` (Logique trit-√†-trit 24t). `Func = MAX_F`.
*   `INV Rd, Rs1` : `Rd <- TRIT_INV(Rs1)` (Logique trit-√†-trit 24t, Rs2 ignor√©). `Func = INV_F`.
*   `SLT Rd, Rs1, Rs2`: Set if Less Than (Signed). `Rd <- (Rs1 < Rs2) ? 1 : 0`. Met √† jour Rd bas√© sur comparaison sign√©e. `Func = SLT_F`.
*   `SLTU Rd, Rs1, Rs2`: Set if Less Than (Unsigned). `Rd <- (Rs1 < Rs2) ? 1 : 0`. N√©cessite de d√©finir l'arithm√©tique non sign√©e ternaire. `Func = SLTU_F`. *(Optionnel pour POC initial)*
*   `CMP Rs1, Rs2` : Met √† jour FR sans √©crire dans Rd. Peut utiliser un `Rd=R0` fictif ou un `Func` d√©di√©. `Func = CMP_F`.

**Op√©rations avec Imm√©diat (Format I)**
*   `ADDI Rd, Rs1, imm`: `Rd <- Rs1 + SignExtend(imm)` (imm 5 trits).
*   `SUBI Rd, Rs1, imm`: `Rd <- Rs1 - SignExtend(imm)` (imm 5 trits).
*   `MINI Rd, Rs1, imm`: `Rd <- TRIT_MIN(Rs1, SignExtend(imm))` (Logique).
*   `MAXI Rd, Rs1, imm`: `Rd <- TRIT_MAX(Rs1, SignExtend(imm))` (Logique).
*   `INVI Rd, Rs1` : `Rd <- TRIT_INV(Rs1)` (imm ignor√©). Peut utiliser ce format si OpCode diff√©rent de Format R.
*   `SLTI Rd, Rs1, imm`: `Rd <- (Rs1 < SignExtend(imm)) ? 1 : 0` (Signed).
*   `SLTIU Rd, Rs1, imm`: `Rd <- (Rs1 < SignExtend(imm)) ? 1 : 0` (Unsigned). *(Optionnel)*
*   `LOADW Rd, imm(Rs1)`: `Rd <- Mem[Rs1 + SignExtend(imm)]` (Charge mot 24t, adresse align√©e sur 8 trytes).
*   `LOADT Rd, imm(Rs1)`: `Rd <- SignExtend(Mem[Rs1 + SignExtend(imm)])` (Charge tryte 3t, √©tend le signe sur 24t).
*   `LOADTU Rd, imm(Rs1)`: `Rd <- ZeroExtend(Mem[Rs1 + SignExtend(imm)])` (Charge tryte 3t, √©tend avec des z√©ros). *(Optionnel)*
*   `JALR Rd, imm(Rs1)`: Jump And Link Register. `temp <- PC + 4; PC <- (Rs1 + SignExtend(imm)) & ~1 ; Rd <- temp`. Saut indirect, l'adresse cible doit √™tre align√©e (ici sur 1 tryte?).

**Op√©rations de Stockage (Format S)**
*   `STOREW Base, Src, offset`: `Mem[Base + SignExtend(offset)] <- Src` (Stocke mot 24t, adresse align√©e sur 8 trytes).
*   `STORET Base, Src, offset`: `Mem[Base + SignExtend(offset)] <- Src[2:0]` (Stocke tryte poids faible 3t).

**Chargement d'Imm√©diat Sup√©rieur (Format U)**
*   `LUI Rd, imm`: Load Upper Immediate. `Rd <- imm << N` (N √† d√©finir, ex: 12 trits ? pour construire constantes 24t avec ADDI). Place `imm` (7 trits) dans les trits sup√©rieurs de Rd, met les inf√©rieurs √† z√©ro.

**Sauts Inconditionnels (Format J)**
*   `JAL Rd, offset`: Jump And Link. `Rd <- PC + 4; PC <- PC + SignExtend(offset) * 4`. Saut relatif PC.

**Branchements Conditionnels (Format B)**
*   `BRANCH cond, offset`: `if (condition(FR) == true) PC <- PC + SignExtend(offset) * 4`.
    *   Conditions (`cond` 3 trits) : `EQ` (ZF=1), `NE` (ZF=0), `LT` (SF=0, ZF=0), `GE` (SF=1 ou ZF=1), `XS` (XF=1), `XN` (XF=0), etc. D√©finir la table des 27 conditions.

**Instructions Syst√®me / Divers (OpCodes d√©di√©s)**
*   `NOP` (No Operation) : Souvent `ADDI R0, R0, 0`.
*   `HALT`: Arr√™te la simulation. OpCode d√©di√©.
*   `EBREAK`: Environment Breakpoint (pour d√©bogage).
*   `ECALL`: Environment Call (appel syst√®me vers l'environnement/OS).
*   *(Optionnel)* Instructions CSR (Control and Status Register) pour g√©rer les registres de contr√¥le avanc√©s (timers, compteurs, interruptions...).

### 4.6 Modes d'Adressage Support√©s
*   **Imm√©diat :** Dans l'instruction (Formats I, S, B, U, J).
*   **Registre Direct :** Op√©rande dans un GPR (Formats R, I, S, B).
*   **Base + Offset :** Pour Load/Store (`Reg[Base] + offset`).
*   **PC-Relatif :** Pour Sauts/Branchements (`PC + offset`).
*   **Registre Indirect :** Pour `JALR` (`Reg[Rs1] + offset`).

## 5. Consid√©rations Suppl√©mentaires

*   **Arithm√©tique Non Sign√©e :** Le ternaire √©quilibr√© est naturellement sign√©. D√©finir une interpr√©tation et des op√©rations non sign√©es n√©cessite une convention sp√©cifique (ex: utiliser un bit/trit de signe s√©par√© ou une repr√©sentation biais√©e). Pour le POC, se concentrer sur l'arithm√©tique sign√©e est plus simple.
*   **Interruptons et Exceptions :** Non d√©finies dans cette phase, mais cruciales pour un syst√®me r√©el. N√©cessiteraient des registres CSR d√©di√©s (comme `mcause`, `mepc`, `mtvec` dans RISC-V) et des m√©canismes pour sauvegarder/restaurer le contexte et d√©router le contr√¥le vers des gestionnaires.
*   **Atomicit√© :** Instructions atomiques (ex: `AMOADD`, `AMOSWAP`) non d√©finies, utiles pour la synchronisation en environnement multi-thread/multi-core (tr√®s avanc√©).
*   **Multiplication/Division :** L'absence d'instructions rapides MUL/DIV est une limitation majeure pour la performance.

## 6. Conclusion de la Phase 3 (R√©vis√©e)

Cette phase a d√©fini l'architecture syst√®me √©tendue de **LGBT+**, en pr√©cisant :
1.  Les unit√©s de donn√©es **Trit, Tryte (3t, adressable), Word (24t)**.
2.  L'organisation des **Registres (8 GPR 24t, PC 24t, SP 24t, FR 3t)**.
3.  Le mod√®le **M√©moire (16 MTrytes, adressage 16t, Little-Endian, alignement)**.
4.  Une **ISA RISC-like d√©taill√©e** (LGBT+ ISA v1.0) avec :
    *   Longueur d'instruction fixe **12 trits (4 trytes)**.
    *   Formats d'instructions **R, I, S, B, U, J** adapt√©s.
    *   Un **ensemble d'instructions de base** (transfert, arithm√©tique sign√©e, logique, contr√¥le de flux) inspir√© de RV32I.
    *   Les **modes d'adressage** cl√©s.

Cette d√©finition d√©taill√©e de l'architecture syst√®me fournit le cadre n√©cessaire pour passer √† la **Phase 4 : Simulation et Test**, o√π un simulateur Rust impl√©mentera cette ISA et ex√©cutera des programmes de test.
```