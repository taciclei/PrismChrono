
# Projet : POC Ordinateur Ternaire Base 24
# Architecture : üè≥Ô∏è‚Äçüåà Logic GPR Base-24 Ternary + (LGBT+)

*   **L** : Logic (Logique ternaire √©quilibr√©e)
*   **G** : GPR (Utilisation de Registres G√©n√©raux)
*   **B** : Base-24 (Syst√®me de num√©ration principal pour les Trytes)
*   **T** : Ternary (Technologie de trit sous-jacente)
*   **+** : Extras (√âtats sp√©ciaux, architecture √©tendue au-del√† du binaire, mots 24 trits)

---

# Phase 2 : Unit√© Arithm√©tique et Logique (ALU) pour l'Architecture √âtendue

**Version :** 2.0 (Adapt√©e √† l'architecture 24 trits / 16 MTrytes)
**Date :** 2024-08-28
**D√©pendances :**
*   Phase 1 - D√©finition Fondamentale (v1.2 - Base Tryte/B24/Ternaire)
*   Phase 3 - Architecture Syst√®me (vX.Y - Doit √™tre mise √† jour pour refl√©ter les mots 24t, adresses 16t, ISA r√©vis√©e)

## 1. Introduction

Cette phase d√©finit la conception fonctionnelle de l'Unit√© Arithm√©tique et Logique (ALU) pour l'architecture **LGBT+** √©tendue. L'ALU est le c≈ìur computationnel, ex√©cutant les op√©rations arithm√©tiques et logiques sp√©cifi√©es par le jeu d'instructions (ISA).

Conform√©ment √† l'√©volution de l'architecture, cette ALU op√®re d√©sormais sur des **Mots (Words) de 24 trits**. Chaque mot est compos√© de 8 Trytes. L'ALU prend en entr√©e des mots de 24 trits, effectue une op√©ration, produit un r√©sultat de 24 trits, et met √† jour les indicateurs d'√©tat (Flags). La gestion des √©tats sp√©ciaux (`UNDEF`, `NULL`, `NaN`) d√©finis au niveau du Tryte doit √™tre consid√©r√©e au niveau du Mot.

## 2. Concepts Fondamentaux de l'ALU 24 Trits

### 2.1 Unit√© d'Op√©ration : Le Mot (Word) de 24 Trits
L'ALU effectue ses op√©rations principales sur des donn√©es de 24 trits. La repr√©sentation interne utilise la logique ternaire √©quilibr√©e `{N, Z, P}`.

### 2.2 Architecture Fonctionnelle (Conceptuelle)
L'ALU re√ßoit typiquement :
*   Op√©rande A (24 trits).
*   Op√©rande B (24 trits).
*   Code d'Op√©ration (issu de l'instruction d√©cod√©e).
*   Potentiellement un Carry-In (1 trit) pour les op√©rations cha√Æn√©es (ex: addition multi-mots).

L'ALU produit :
*   R√©sultat R (24 trits).
*   Flags d'√©tat (stock√©s dans le registre FR).

```
      +-------------------+          +-------------------+
      | Op√©rande A (24t)  |----------|                   |
      +-------------------+          |                   |
                                     |        ALU        |-----> R√©sultat R (24t)
      +-------------------+          |   (Logique Interne|
      | Op√©rande B (24t)  |----------|   Ternaire 24t)   |---+---> Flags (ZF, SF, XF, CF, OF...)
      +-------------------+          |                   |   |   +-------------------+
                                     |                   |
      +-------------------+          |                   |
      | OpCode / Control  |----------|                   |
      +-------------------+          +-------------------+
            (Carry-In)---------------->|
```

### 2.3 Gestion des √âtats Sp√©ciaux au Niveau du Mot
Une convention doit √™tre √©tablie sur comment les √©tats sp√©ciaux (`UNDEF`, `NULL`, `NaN` d√©finis par Tryte) sont g√©r√©s quand ils apparaissent dans un mot de 24 trits :
*   **Option 1 (Stricte) :** Si *n'importe quel* Tryte dans un mot op√©rande est `UNDEF`, `NULL`, ou `NaN`, le mot entier est trait√© comme invalide pour les op√©rations arithm√©tiques, r√©sultant en `NaN` (repr√©sentation 24 trits de NaN) et `XF=1`. Les op√©rations logiques pourraient op√©rer trit-√†-trit mais propager les √©tats sp√©ciaux.
*   **Option 2 (Propagative Logique) :** Les op√©rations logiques op√®rent trit-√†-trit. Les op√©rations arithm√©tiques √©chouent (r√©sultat `NaN`, `XF=1`) si un op√©rande contient `NaN`. La gestion de `NULL` ou `UNDEF` en arithm√©tique n√©cessite des r√®gles pr√©cises (souvent -> `NaN`).
*   **Repr√©sentation 24t des √âtats Sp√©ciaux :** Faut-il des motifs 24 trits sp√©cifiques pour `UNDEF`, `NULL`, `NaN` au niveau du mot, ou suffit-il de tester les Trytes individuels ? Pour le POC, la d√©tection d'un Tryte sp√©cial dans un op√©rande (Option 1 ou 2 simplifi√©e) est suffisante. D√©finissons un **Mot NaN** comme √©tant (par exemple) 8 Trytes `NaN` : `(NaN, NaN, ..., NaN)`.

*   **D√©cision POC :** Adopter l'Option 2 simplifi√©e : Si un op√©rande A ou B contient un Tryte `NaN`, le r√©sultat est le **Mot NaN**. Si A ou B contient `UNDEF` ou `NULL`, le r√©sultat arithm√©tique est le **Mot NaN**. Mettre `XF=1` si le r√©sultat est `NaN`, `NULL`, ou `UNDEF`.

## 3. Op√©rations Arithm√©tiques (sur Mots de 24 trits)

L'arithm√©tique sur 24 trits est effectu√©e en utilisant la logique ternaire √©quilibr√©e.

### 3.1 Additionneur Complet Ternaire (TFA) : Le Bloc de Base
Le TFA (d√©fini en v1.0) reste la brique √©l√©mentaire. Un additionneur 24 trits serait conceptuellement construit en cha√Ænant 24 TFA (ex: Ripple Carry Adder), ou en utilisant des techniques plus rapides (Carry Lookahead adapt√© au ternaire).

`a[i] + b[i] + carry_in[i] = sum[i] + 3 * carry_out[i]` (pour chaque position de trit `i`)

### 3.2 Addition 24 trits (ADD A, B)
1.  V√©rifier A, B pour la pr√©sence de Trytes `NaN`, `NULL`, `UNDEF`. Si trouv√© (selon r√®gle 2.3), retourner le **Mot NaN** et mettre `XF=1`.
2.  Effectuer l'addition ternaire √©quilibr√©e sur les 24 trits, en propageant la retenue (`carry`) du trit `i` au trit `i+1`.
3.  Le r√©sultat est un mot R de 24 trits.
4.  Mettre √† jour les flags :
    *   `ZF`: 1 si R est le mot z√©ro (tous trits Z), 0 sinon.
    *   `SF`: 1 si le r√©sultat R (interpr√©t√© en Bal3 sign√©) est >= 0, 0 si < 0.
    *   `XF`: 1 si le r√©sultat R est un √©tat sp√©cial (ex: NaN suite √† overflow), 0 sinon.
    *   `CF`: Retenue ternaire {N, Z, P} sortant du 24√®me trit (trit 23).
    *   `OF`: Indicateur de d√©passement de capacit√© sign√© (Overflow). √Ä d√©finir pr√©cis√©ment (ex: si le signe des op√©randes et le signe du r√©sultat sont incoh√©rents avec l'op√©ration). Si OF=1, le r√©sultat pourrait √™tre mis √† `NaN` ou saturation (non d√©fini ici).

### 3.3 Soustraction 24 trits (SUB A, B)
Impl√©ment√©e via `A + INV(B) + Carry_In(P)` (pour la compl√©mentation √† 1 en ternaire √©quilibr√©, ou simplement `A + INV(B)` o√π INV est la n√©gation 24 trits).
1.  V√©rifier A, B pour √©tats sp√©ciaux (comme ADD).
2.  Calculer `INV(B)` : Inverser chaque trit de B (`N<->P`, `Z->Z`).
3.  Effectuer l'addition ternaire 24 trits `A + INV(B)`.
4.  Le r√©sultat est un mot R de 24 trits.
5.  Mettre √† jour les flags (similaire √† ADD). `CF` repr√©sente maintenant un "emprunt" (borrow).

### 3.4 Multiplication (MUL) et Division (DIV) 24 trits
*   Encore plus complexes que pour 9 trits. Op√®rent sur des op√©randes 24 trits et produisent potentiellement un r√©sultat sur 48 trits (pour MUL).
*   N√©cessiteraient des algorithmes multi-cycles d√©di√©s (d√©calages/additions ternaires) ou un co-processeur mat√©riel.
*   **D√©finition POC :** Reconnus comme n√©cessaires mais **non impl√©ment√©s dans l'ALU de base**. Les OpCodes correspondants pourraient g√©n√©rer une exception "non impl√©ment√©" ou appeler des routines logicielles lentes.

## 4. Op√©rations Logiques (Trit-√†-Trit sur Mots de 24 trits)

Ces op√©rations appliquent les portes logiques ternaires de base (Phase 1) √† chaque position de trit correspondante des mots de 24 trits.

**Gestion des √âtats Sp√©ciaux :** Les op√©rations logiques op√®rent directement sur les trits, y compris ceux composant les repr√©sentations des Trytes sp√©ciaux. Le r√©sultat est un mot de 24 trits qui peut contenir des Trytes valides ou sp√©ciaux.
*   Si un op√©rande est le **Mot NaN**, le r√©sultat est le **Mot NaN**. Mettre `XF=1`.

### 4.1 Inverseur Logique (TRIT_INV A)
Applique `INV(trit)` √† chaque trit du mot A (de t0 √† t23).
*   `R[i] <- INV(A[i])` pour `i = 0..23`.
*   Mise √† jour des flags ZF, SF, XF bas√©e sur le mot r√©sultat R.
*   **Exemple :** `TRIT_INV(Word_Zero)` -> `Word_Zero`. `TRIT_INV(Mot_NaN)` -> `Mot_Zero` (si Mot_NaN est P..P et Mot_Zero est N..N apr√®s offset).

### 4.2 Minimum Logique (TRIT_MIN A, B)
Applique `MIN(trit_A, trit_B)` trit √† trit sur 24 trits.
*   `R[i] <- MIN(A[i], B[i])` pour `i = 0..23`.
*   Mise √† jour ZF, SF, XF bas√©e sur R.

### 4.3 Maximum Logique (TRIT_MAX A, B)
Applique `MAX(trit_A, trit_B)` trit √† trit sur 24 trits.
*   `R[i] <- MAX(A[i], B[i])` pour `i = 0..23`.
*   Mise √† jour ZF, SF, XF bas√©e sur R.

## 5. Op√©rations de Comparaison (sur Mots de 24 trits)

Effectu√©es g√©n√©ralement via une soustraction `A - B` sans stocker le r√©sultat, en analysant uniquement les flags produits (`ZF`, `SF`, `XF`, `CF`, `OF`).
*   **Instructions D√©di√©es :** Une instruction `CMP A, B` (ou `CMPI A, imm`) est typique.
*   **Conditions :** Les branchements conditionnels (Phase 3) utiliseront ces flags pour d√©terminer l'√©galit√© (`ZF=1, XF=0`), la diff√©rence (`ZF=0` ou `XF=1`), la sup√©riorit√©/inf√©riorit√© sign√©e (bas√©e sur `SF`, `ZF`, `OF`, `XF`), etc.
*   **Comparaison avec √âtats Sp√©ciaux :** D√©finir le comportement lors de la comparaison avec des mots contenant `UNDEF`, `NULL`, ou `NaN`. G√©n√©ralement, `NaN` n'est √©gal/inf√©rieur/sup√©rieur √† rien. `NULL` n'est √©gal qu'√† `NULL`.

## 6. Indicateurs d'√âtat (Flags) pour l'ALU 24 Trits

Le registre FR stocke les flags mis √† jour par l'ALU. Ils refl√®tent le r√©sultat de l'op√©ration sur **24 trits**.

**Flags Propos√©s (Pr√©cis√©s pour 24t) :**

| Flag | Nom                | Signification (pour r√©sultat R de 24 trits)                                                                                    | Type      | Stockage (ex: FR 3t) |
| :--- | :----------------- | :----------------------------------------------------------------------------------------------------------------------------- | :-------- | :------------------- |
| `ZF` | Zero Flag          | 1 si R est le mot 24 trits Z√©ro (tous Z), 0 sinon.                                                                             | Binaire   | t0 (P=1, Z=0)        |
| `SF` | Sign Flag          | 1 si R (interpr√©t√© comme Bal3 sign√©) est >= 0, 0 si < 0. Ind√©fini si XF=1.                                                       | Binaire   | t1 (P=1, Z=0)        |
| `XF` | Special Flag       | 1 si R contient/est un √©tat sp√©cial (`UNDEF`/`NULL`/`NaN` au niveau mot/tryte), 0 si R est un mot de chiffres B24 valides.       | Binaire   | t2 (P=1, Z=0)        |
| `CF` | Carry Flag         | Retenue/Emprunt ternaire {N, Z, P} sortant du trit 23 lors d'ADD/SUB. Peut n√©cessiter un stockage s√©par√© si FR est binaire.      | Ternaire  | Externe ou FR √©tendu |
| `OF` | Overflow Flag      | 1 si l'op√©ration arithm√©tique sign√©e a provoqu√© un d√©passement de capacit√© sur 24 trits. 0 sinon.                                | Binaire   | Externe ou FR √©tendu |

*Note : Pour le POC initial, un FR de 3 trits stockant ZF, SF, XF (binaires) pourrait suffire, en ignorant CF/OF ou en les g√©rant implicitement.*

## 7. Am√©liorations Possibles et Consid√©rations Futures

*   **ALU Pipelined :** Pour augmenter le d√©bit d'instructions, l'ALU pourrait √™tre divis√©e en √©tages (ex: Fetch, Decode, Execute, Writeback).
*   **Unit√©s d'Ex√©cution Multiples :** Avoir plusieurs ALU ou des unit√©s sp√©cialis√©es (ex: pour les sauts, pour la m√©moire).
*   **Multiplication/Division Mat√©rielle :** Ajouter une unit√© d√©di√©e pour acc√©l√©rer ces op√©rations cruciales.
*   **Op√©rations de D√©calage/Rotation Ternaire :** D√©finir des instructions `SHIFT_LEFT`, `SHIFT_RIGHT`, `ROTATE` adapt√©es au ternaire.
*   **Support Arithm√©tique √† Saturation :** Optionnellement, au lieu de g√©n√©rer `NaN` ou de boucler sur overflow, saturer le r√©sultat √† la valeur maximale/minimale repr√©sentable.
*   **Vectorisation (SIMD - Single Instruction, Multiple Data) :** Op√©rer sur plusieurs Trytes ou mots plus petits en parall√®le (tr√®s avanc√©).
*   **D√©finition des Patterns Sp√©ciaux 24t :** Fixer les repr√©sentations exactes de `UNDEF`, `NULL`, `NaN` pour un mot de 24 trits.

## 8. Conclusion de la Phase 2 (R√©vis√©e)

Cette phase a d√©fini l'ALU de l'architecture LGBT+ √©tendue, op√©rant sur des **mots de 24 trits** :
1.  Les op√©rations **arithm√©tiques (ADD, SUB)** et **logiques (TRIT_INV, TRIT_MIN, TRIT_MAX)** sont d√©finies pour cette largeur.
2.  La gestion des **√©tats sp√©ciaux** au niveau du mot est esquiss√©e.
3.  Un ensemble de **flags (ZF, SF, XF, CF, OF)** refl√©tant l'√©tat des op√©rations 24 trits est propos√©.
4.  La complexit√© accrue (ALU 24t, MUL/DIV) est not√©e.
5.  Des pistes d'am√©liorations futures sont list√©es.

Cette ALU plus puissante est une composante cl√© de l'architecture √©tendue. La prochaine √©tape majeure est de **red√©finir l'ISA en Phase 3** pour exploiter cette ALU et g√©rer l'adressage 16 trits, avant de mettre √† jour le simulateur en Phase 4.
```